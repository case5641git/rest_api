## WebAPI とは

### Web の仕組み

クライアントからサーバー、サーバーからクライアントのやりとり

WEB とは技術やサービスのこと

WEB API とは：規約やサービスの実装

WEB サイト：静的コンテンツ

WEB サービス：動的コンテンツ、ユーザーの情報に対して情報を出し入れ

API エコノミーの実現により自社サービスの発展

価値のあるものは全て公開

価値あるもの：飲食店の検索、予約、人気店の検索、口コミの検索、投稿、修正、削除

価値のないもの：郵便番号検索

WebAPI 公開によるリスクと対策

一番の問題は「入るはずの利益が入らなくなること」

ユーザーが減る、リソースの圧迫

対策

ユーザーが減る：ユーザー獲得している他のサービスの機能を取り込む、該当サービスに対して WebAPI の提供を停止する →API キー停止

リソースの圧迫：該当サービスに対して WebAPI の利用制限をかける → レートリミット

### HTTP 通信の中身

リクエスト

リクエストライン：メソッド(8 種)、リクエスト URI、HTTP バージョン

ヘッダー：さまざまなメタデータが含まれる、User-Agent、Content-type、Cookie

ボディ：サマざななデータ

レスポンス

ステータスライン：HTTP バージョン、ステータスコード、フレーズ

ヘッダー：ステータスラインで表現できない追加情報

ボディ：任意のデータを入れることができる

### 安全性と冪等性

副作用：リソース(データ)が改変されること。

副作用がある：データを更新するとき

副作用がない：データを取得するとき

安全とは副作用がないこと、リソースの状態を変化させない読み取り操作

冪等：副作用の有無は問わず、何度実行しても同じ状態が再現される。

副作用があるケース：店舗の番号を指定して、毎回同じ店舗名に更新する PUT、DELETE など

副作用がないケース：データ取得、何度取得してもサーバーの状態は変わらない

安全でも冪等でもない：データ登録 POST によるデータ新規登録

### RESTful とは

REST で求められる原則に従っていること

REpresentational State Transfar：分散型システムおける設計ルール

REST 原則は 6 種

クライアント/サーバー

画面とデータで関心ごとを分離

クライアント側がトリガー、サーバー側は受け身

階層化システム

3 層構成,多層アーキテクチャ：Web、AP、DB

一つのサーバーのことをコンポーネントという

メリット

各システムに役割を決めて独立させることで、進化と再利用が促進できる

デメリット

データ処理にオーバーヘッドが発生

ユーザーから見ると応答が悪くなる

コードオンデマンド

クライアントコードをダウンロードして実行できる。

リリース後にクライアントコードを変更できる。

メリット：

リリース済みのクライアントに対して機能追加ができる

サーバーの負荷が下がる

デメリット：

評価環境は複雑になる

統一インターフェース

4 つの制約

リソースの識別

リソース：サーバー側に保持されているデータ

URI を用いてサーバーに保存されたデータを識別する

抽象的な定義も含む、「最新」もリソース

URI はリソースを識別するもの、動作は含まない

表現を用いたリソース操作

リソースのある断面

クライアントへ返されるレスポンスやサーバーへ POST するデータ

自己記述メッセージ

データ自身がデータの中身を説明している

HATEOAS

レスポンスに現在の状態を踏まえて関連するハイパーリンクが含まれている

ハイパーリンク

メリット：

システムアーキテクチャ全体が簡素化される

提供するサービスに集中でき、独自の進化ができる

異なるブラウザでも同じような画面を表示できる

デメリット

標準化によって効率化が犠牲になる

ステートレス

ステートフル：前の状態を保存

ステートレス：前の状態を保存しない、それぞれの通信が独立して成立

サーバーはリクエストだけでコンテキストを理解できる

メリット

単一のリクエスト以外みる必要がない、監視が簡単

障害復旧が簡単

サーバーのスケールアウトが簡単

デメリット

リクエストデータに重複がある

アプリを複数バージョン同時提供し、状態をクライアントに置いておくとアプリ制御が複雑になる

キャッシュ制御

レスポンスは明示的または暗黙的にキャッシュ可能

キャッシュを適切に行うことでクライアント/サーバー間の通信が排除され、ユーザー体験の向上、リソース効率の向上、拡張性の向上が見込める

メリット

ユーザー体験の向上

リソース効率の向上

拡張性の向上

デメリット

古いデータを戻してしまうとシステムに対する信頼性の低下

REST API 設計レベル

設計レベルは 4 段階

LEVEL 0：HTTP を使っている、RPC スタイルの XML 通信

LEVEL1：リソースごとに URL を分割

LEVEL2：HTTP メソッドを活用 POST,PUT,GET,DELETE

LEVEL3：HATEOAS の概念を導入 LEVEL2 に加えてレスポンスにリソース間のつながりが含まれる

### サービス設計

URI の設計

短く入力しやすい → シンプルで覚えやすいものにすることで入力ミスを防ぐ

人が読んで理解できる、省略が自己満足になっていないか？国や文化が変わっても普遍な表記にする

大文字小文字が混在していない、全て小文字

単語はハイフンで繋げる

アンダースコアはタイプライターで下線を引くためのもの、ハイフンは単語をつなぐためのもの

単語は複数形を利用する

URI で表現しているのはリソースの集合

エンコードを必要とする文字を使わない

URI から意味が理解できない

サーバー側のアーキテクチャを反映しない

悪意あるユーザーに脆弱性を疲れる危険がある

改造しやすい(Hackable)

システム依存の設計は意味が理解できない

ルールが統一されている

一定のルールに従って設計るすることで間違いを防ぐ

HTTP メソッドの適用

URI がリソースを示す

HTTP メソッドはリソースに対する操作を示す

クエリとパスの使い分け

クエリパラメータ

URL の末尾にある?に続くキーバーリュー

パスパラメータ

URL 中に埋め込まれるパラメータ

クエリパラメータとするかどうかの判断基準

一意なリソースを表すのに必要かどうか

パスパラメータ

省略可能かどうか

クエリパラメータ

ステータスコード

役割

処理結果の概要を把握するためのもの

HTTP メソッドとステータスコード

GET

成功：200 OK , 304 Not Modified ,

失敗：400 Bad Request , 401 Unauthorized , 403 Forbidden , 404 Not Found , 429 Too Many Requests , 500 Internal Server Error , 502 Service Unavaliable

POST

成功：200 OK , 201 Created , 202 Accepted ,

失敗 : 400 Bad Request , 401 Unauthorized , 403 Forbidden , 409 Conflict , 500 Internal Server Error , 503 Service Unavaliable

PUT

成功 : 200 OK , 201 Created(登録時) , 204 No Content(更新) ,

失敗 : 400 Bad Request, 401 Unauthorized , 403 Forbidden , 404 Not Found , 409 Conflict , 429 Too Many Request ,500, 503

DELETE

成功：200 OK(あまり使わない) , 202 Accepted(非同期処理の削除) , 204 No Content(できるだけこれを返す)

失敗：400 Bad Request , 401, 403, 404 , 429, 500, 503

データフォーマット

主要なデータフォーマット

XML

テキスト形式

タグで記述

タグは入れ子にできる

タグに属性がつけられる

JSON

テキスト形式

JavaScritpt をもとにしたフォーマット

XML に比べてデータ量を減らせる

オブジェクトは入れ子にできる

JSONP

テキスト形式

データフォーマットのように見えるが JavaScript コード

クロスドメインでデータを受け渡すことができる

フォーマットの指定方法

クエリパラメータ：実サービスで利用が多い

拡張子：あまり見ない

リクエストヘッダー：URI がリソースであることを考えるとリクエストヘッダーが一番行儀がいい

データの内部構造

エンベロープは使わない

レスポンスのヘッダー情報と被るので使わない

適切な HTTP ステータスを使いシンプルに返す

オブジェクトはできるだけフラットにする

レスポンス容量を減らすため

ページネーションをサポートする情報を返す

相対的なページの返し方は ×、情報が更新される可能性があるため

次をどこから取得するのかキーとなる情報を返す

プロパティの命名規則は API 全体で統一する

プロパティの命名規則は API 全体で統一する → 利用者が混乱するため

スネークケースはキャメルケースより可読性が高いと言われている

JSON が JS ベースであること、プロパティ名は変数名に相当すると捉えるならキャメルケースが妥当

日付は RFC3339(W3C-DTF)形式を使う

2024-08-28T17 : 00 : 00+09 : 00

大きな数値 (64bit 整数)は文字列で返す

JS で扱える演算可能な最大整数は 2^53 - 1

エラー表現

エラー詳細はレスポンスボディに入れる

ステータスコードだけでは詳細はわからない

エラーの際に HTML が返らないようにする

レスポンスフォーマットが変わると、クライアントアプリ側で処理できないケースがある

サービス閉塞時は 503 + Retry-After

クライアント側から見ていつから再開して良いかわかる

API バージョンの表現

API バージョンを含めるか？

メリット：特定バージョン指定でアクセスできるので、クライアンド側で突然エラーにならない

デメリット：複数バージョンを並列稼働させるため、ソースコードやデータベースの管理が複雑になる

広く世間に一般に公開するようなサービスかどうか？

バージョンを入れられる場所

パス：このケースが多い

クエリ

ヘッダー：2012/6 以降は”x-接頭辞”は非推奨、サービス固有の接頭辞をつける

設計上はヘッダーに入れるのがおすすめ

バージョンの付け方

セマンティックバージョニング

サンプル ver : メジャー・マイナー・パッチ

メジャー：後方互換しない修正

マイナー：マイナー

パッチ：後方互換するバグ修正

API は後方互換しなくなったタイミングでつける

メジャーバージョンのみ利用

マイナーやパッチをつけると管理工数が増えてしまう

OAuth と OpenID Connect：どちらとも認可の仕組み

認証と認可

認証：本人特定

認可：アクセス制御

OAuth：認可

1. リソースを持っているユーザーがサードパてぃアプリケーションに連携リクエスト
2. サービスからユーザーへ連携画面を表示
3. ユーザーがログイン
4. サービスがサードパーティに認可コードを転送
5. サードパーティーがサービスにアクセスして、アクセストークンを受け取る
   1. 認可を持たせたキー情報
6. API アクセス / アクセストークンを用いてサービスを利用

OpenID Connect：OAuth + 本人情報取得

code フローの場合

基本 OAuth と似ているが、サービスからアクセストークンを返すと同時に ID トークンも返す。この ID トークンが JWT と呼ばれるもの

アプリからサービスにアクセスするときに個人情報も付加する

JSON Web TOKEN (JWT ジョット)

仕様：RFC 7519 で標準化

特徴

署名による改ざんチェック

URL-safe なデータ

データの中身は JSON

用途

認証結果をサーバーサイドで保存せずクライアントサイドで保持、ステートレスな通信の実現

基本構造

ピリオド２つで区切られた 3 要素で構成される

ヘッダー

JSON 形式の文字列

署名で利用するアルゴリズムなどを定義

ペイロード

保存したいデータの実態

iss : issuer JWT を発行しているサービス、システムの識別し

sub : Subject 同一 issuer 内での識別し

aud : Audience JWT を利用しているサービス、システムの識別し

exp : Expiration TIme JWT の有効期限

jti : JWT ID JWT の再利用を防ぐために利用する一意の識別し

署名

改竄されていないかを確認するための署名

ヘッダーとペイロードを繋ぎ合わせた文字列を任意の署名を作成

大量アクセス対策

レートリミット

Web サービスを API 化することで発生する問題

意図しない、プログラマの不注意で大量アクセスが発生する

対策

時間あたりのアクセス制限をかける → レートリミット

レートリミット

誰に対して

何に対して

制限回数

単位時間

レートリミットの実現方法

30 回/10 分のレートリミットの場合

Fixed Window

一定の時間内に規定のリクエスト回数内であればリクエストが受け入れられる。決まった時間が過ぎるとカウンターがリセットされる

境界前後の枠で見るとレートリミットの倍のアクセスがある場合がある

Sliding Log

過去 10 分間のログを確認、30 件溜まっていたらリクエストを拒否。過去のリクエストが 30 件未満になったらリクエストを受け入れる

過去ログを大量に保存する必要がある

ログの破棄も考える必要がある

Sliding Window

過去 10 分間のリクエスト数比率を計算

preCount : 過去 Window のリクエスト数

curCount : 現在の Window のリクエスト数

x : 境界からリクエストがあった時間

$$
preCount * (1 - (x分 / 10分)) + curCount  < 30回
$$

アクセス制限の緩和

サービス利用が多く、自社にとって優良顧客である場合

キャンペーンなど、一時的に付加増大がある場合

キャッシュ制御

Expires ヘッダー

キャッシュとしていつまで利用可能かの期限を指定

過去日を指定すると「リソースが有効期限切れ」であることを意味する

Cache-Control が同時に指定されている場合、Expires は無視

Cache-Control + Date

Chache-Control でキャッシュの「可否」「期限」を指定

キャッシュ可否

public：通信経路上のどこでも保存できる

private：クライアント端末のみに保存

no-cache : クライアント側に保存されている、通信量が抑えられるので高速

no-store：クライアント側にも保存されない、必ずデータのやり取りが発生する

キャッシュ期限

max-age=<秒> : 新しいとみなせる時間

Last-Modified + ETag

リソースの最終更新日時を指定

ETag に特定バーションを示す文字列を指定

キャッシュさせる単位

応答言語によってキャッシュを分けたいケース

Vary : キャッシュ判断に利用するヘッダー情報を指定

セキュリティ

API はどこから呼ばれるのか

悪意あるユーザーが仕様するリスクもある

XSS

脆弱性：悪意あるユーザーが正規の際にとに不正なスクリプトを挿入することで、正規ユーザーの情報を不正に引き出したり操作できてしまう問題

対策：

レスポンスヘッダーの追加

X-XSS-Protection : “1”で XSS フィルタリング有効か

X-Frame-Options : “DENY”で frame の呼び出しを拒否

CSRF

脆弱性：本来拒否しなければいけないアクセスもとからくるリクエストを処理してしまう問題

対策：

許可しないアクセス元からのリクエストを拒否

X-API-Key : システム単位で実行可否判断

Authentication : ユーザー単位で実行可否判断

攻撃者に推測されにくトークンの発行/商号処理を実装

X-CSRF-TOKEN : トークンを使って実行可否判断

HTTP

脆弱性：通信経路が暗号化されていないので盗聴されやすい

対策：

常時 HTTPS を利用した通信にする

補足：SSL/TLS/HTTPS の違い

SSL/TLS : 安全に通信を行うためのプロトコル

HTTPS : HTTP + SSL/TLS を組み込んで Web で安全に通信するプロトコル

JWT

脆弱性：クライアント側で内容の確認、編集が簡単にできるため、サーバー側の検証が不十分だと改竄された情報を正規として受け入れてしまう。

対策：

ヘッダーの alg に none 以外を指定して署名を暗号化する

ペイロードの aud に想定する利用者を指定して受信時に検証する

### 実践

Open API と Swagger

Open API：WSDL や XML と比較される等なフォーマット、JSON もしくは YAML 形式

OpenAPI Specification : Open API を記述するための書式

Swagger : OpenAPI を作成、表示、利用するツール群

Swagger Editor , Swagger Codegen , Swagger UI

Swagger Editor の特徴

オートコンプリート

リアルタイムエラーチェック

リアルタイムに UI 表示

起動方法

Git リポジトリのソースコードをクローン

Docker 環境下
